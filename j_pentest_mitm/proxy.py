#!/usr/bin/env python
# encoding: utf8
from mitmproxy import flow
from mitmproxy.proxy import ProxyServer, ProxyConfig
from mitmproxy.script import concurrent
from netlib.http import decoded
from mitmproxy.models import HTTPResponse
from netlib.http import Headers
from urllib import unquote, urlencode, quote
from urlparse import parse_qs
from pprint import pprint
from flask import Flask
from flask import request as flask_request
import json
import base64
import pickle
import threading
import traceback

import requests

poor_man_global_var = []
global_lock = threading.Lock()

app = Flask("mitmproxy")

@app.route('/')
@app.route('/index')
def hello_world():
    return 'hello'

@app.route( '/status' )
def status():
    global poor_man_global_var
    return len(poor_man_global_var)

@app.route('/list')
def traffic_list():
    try:
        global poor_man_global_var
        global global_lock
        with global_lock:
            r = json.dumps( poor_man_global_var )
            poor_man_global_var = []
        return r
    except:
        traceback.print_exc()

# this domain and port combination will now be routed to the WSGI app instance.
def start(context, argv):
    context.app_registry.add(app, "mitm.com", 80)

def done ( context ):
    print 'exit mitmproxy'

@concurrent
def response( context, flow ):
    req = flow.request
    res = flow.response
    url = req.url
    with decoded( res ):
        with global_lock:
            poor_man_global_var.append( {   
                'url':url,
                'method': req.method,

                'request_headers':dict( req.headers ),
                'request_content':base64.b64encode(req.content),  # raw content

                'response_headers':dict( res.headers ),
                'response_content':base64.b64encode(res.content),
            } )
