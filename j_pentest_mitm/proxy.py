#!/usr/bin/env python
# encoding: utf8
from mitmproxy import flow
from mitmproxy.proxy import ProxyServer, ProxyConfig
from mitmproxy.script import concurrent
from netlib.http import decoded
from mitmproxy.models import HTTPResponse
from netlib.http import Headers
from urllib import unquote, urlencode, quote
from urlparse import parse_qs
from pprint import pprint
from flask import Flask
from flask import request as flask_request
import json
import base64
import threading
import traceback

import requests

poor_man_global_var = []
global_lock = threading.Lock()

app = Flask("mitmproxy")

@app.route('/')
@app.route('/index')
def hello_world():
    return json.dumps( {'status':'ok', 'result':ur''}, indent=4 )

@app.route( '/status' )
def status():
    return 'ok'

@app.route('/clear')
def traffic_clear():
    with global_lock:
        poor_man_global_var = []
    return json.dumps( {'status':'ok', 'result':poor_man_global_var}, indent=4 )

@app.route('/list')
def traffic_record():
    with global_lock:
        r = json.dumps( {'status':'ok', 'result':poor_man_global_var}, indent=4 )
        poor_man_global_var = []
    return r

# this domain and port combination will now be routed to the WSGI app instance.
def start(context, argv):
    context.app_registry.add(app, "mitm.com", 80)

def done ( context ):
    pprint ( poor_man_global_var )

@concurrent
def response( context, flow ):
    req = flow.request
    res = flow.response
    url = req.url
    with decoded( res ):
        poor_man_global_var.append( {   
            'url':url,

            'request':True,
            'request_headers':dict( req.headers ),
            'request_content':base64.b64encode(req.content),

            'response':True,
            'response_headers':headers,
            'response_content':base64.b64encode(res.content),
        } )
